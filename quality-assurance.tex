\documentclass{article}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage{lmodern}%
\usepackage{textcomp}%
\usepackage{lastpage}%
\usepackage{geometry}%
\geometry{margin=2.5cm}%
%
\title{Quality Assurance Notes}%
\author{Patrick Adams}%
\date{\today}%
%
\begin{document}%
\normalsize%
\maketitle%
\newpage%
Note: This is a draft copy of notes generated by free code camp.\newline%
%
https://www.freecodecamp.org/%
\newpage%
\tableofcontents%
\section{Quality Assurance And Testing With Chai}%
\label{sec:QualityAssuranceAndTestingWithChai}%
\subsection{Learn How JavaScript Assertions Work}%
\label{subsec:LearnHowJavaScriptAssertionsWork}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Test if a Variable or Function is Defined}%
\label{subsec:TestifaVariableorFunctionisDefined}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Use Assert.isOK and Assert.isNotOK}%
\label{subsec:UseAssert.isOKandAssert.isNotOK}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
isOk() will test for a truthy value and isNotOk() will test for a falsy value.\newline%
To learn more about truthy and falsy values, try our Falsy Bouncer challenge.\newline%

%
\subsection{Test for Truthiness}%
\label{subsec:TestforTruthiness}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
isTrue() will test for the boolean value true and isNotTrue() will pass when given anything but the boolean value of true.\newline%
```js\newline%
assert.isTrue(true, 'this will pass with the boolean value true');\newline%
assert.isTrue('true', 'this will NOT pass with the string value 'true');\newline%
assert.isTrue(1, 'this will NOT pass with the number value 1');\newline%
```\newline%
isFalse() and isNotFalse() also exist and behave similarly to their true counterparts except they look for the boolean value of false. \newline%

%
\subsection{Use the Double Equals to Assert Equality}%
\label{subsec:UsetheDoubleEqualstoAssertEquality}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
equal() compares objects using ==.\newline%

%
\subsection{Use the Triple Equals to Assert Strict Equality}%
\label{subsec:UsetheTripleEqualstoAssertStrictEquality}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
strictEqual() compares objects using ===.\newline%

%
\subsection{Assert Deep Equality with .deepEqual and .notDeepEqual}%
\label{subsec:AssertDeepEqualitywith.deepEqualand.notDeepEqual}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
deepEqual() asserts that two object are deep equal.\newline%

%
\subsection{Compare the Properties of Two Elements}%
\label{subsec:ComparethePropertiesofTwoElements}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Test if One Value is Below or At Least as Large as Another}%
\label{subsec:TestifOneValueisBeloworAtLeastasLargeasAnother}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Test if a Value Falls within a Specific Range}%
\label{subsec:TestifaValueFallswithinaSpecificRange}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
.approximately(actual, expected, delta, {[}message{]})\newline%
Asserts that the actual is equal expected, to within a +/{-} delta range.\newline%

%
\subsection{Test if a Value is an Array}%
\label{subsec:TestifaValueisanArray}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Test if an Array Contains an Item}%
\label{subsec:TestifanArrayContainsanItem}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Test if a Value is a String}%
\label{subsec:TestifaValueisaString}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
isString or isNotString asserts that the actual value is a string.\newline%

%
\subsection{Test if a String Contains a Substring}%
\label{subsec:TestifaStringContainsaSubstring}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
include() and notInclude() work for strings too!\newline%
include() asserts that the actual string contains the expected substring.\newline%

%
\subsection{Use Regular Expressions to Test a String}%
\label{subsec:UseRegularExpressionstoTestaString}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
match() asserts that the actual value matches the second argument regular expression.\newline%

%
\subsection{Test if an Object has a Property}%
\label{subsec:TestifanObjecthasaProperty}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
property asserts that the actual object has a given property.\newline%

%
\subsection{Test if a Value is of a Specific Data Structure Type}%
\label{subsec:TestifaValueisofaSpecificDataStructureType}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
\#typeOf asserts that valueâ€™s type is the given string, as determined by Object.prototype.toString.\newline%

%
\subsection{Test if an Object is an Instance of a Constructor}%
\label{subsec:TestifanObjectisanInstanceofaConstructor}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
\#instanceOf asserts that an object is an instance of a constructor.\newline%

%
\subsection{Run Functional Tests on API Endpoints using Chai{-}HTTP}%
\label{subsec:RunFunctionalTestsonAPIEndpointsusingChai{-}HTTP}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Run Functional Tests on API Endpoints using Chai{-}HTTP II}%
\label{subsec:RunFunctionalTestsonAPIEndpointsusingChai{-}HTTPII}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\subsection{Run Functional Tests on an API Response using Chai{-}HTTP III {-} PUT method}%
\label{subsec:RunFunctionalTestsonanAPIResponseusingChai{-}HTTPIII{-}PUTmethod}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
In the next example we'll see how to send data in a request payload (body).\newline%
We are going to test a PUT request. The '/travellers' endpoint accepts a JSON object taking the structure:\newline%
```json\newline%
\{\newline%
  "surname": {[}last name of a traveller of the past{]}\newline%
\}\newline%
```\newline%
The route responds with :\newline%
```json\newline%
\{\newline%
  "name": {[}first name{]}, "surname": {[}last name{]}, "dates": {[}birth {-} death years{]}\newline%
\}\newline%
```\newline%
See the server code for more details.\newline%

%
\subsection{Run Functional Tests on an API Response using Chai{-}HTTP IV {-} PUT method}%
\label{subsec:RunFunctionalTestsonanAPIResponseusingChai{-}HTTPIV{-}PUTmethod}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
This exercise is similar to the preceding one. Look at it for the details.\newline%

%
\subsection{Run Functional Tests using a Headless Browser}%
\label{subsec:RunFunctionalTestsusingaHeadlessBrowser}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%
In the next challenges we are going to simulate the human interaction with a page using a device called 'Headless Browser'.\newline%
A headless browser is a web browser without a graphical user interface. This kind of tool is particularly useful for testing web pages, as it is able to render and understand HTML, CSS, and JavaScript the same way a browser would.\newline%

%
\subsection{Run Functional Tests using a Headless Browser II}%
\label{subsec:RunFunctionalTestsusingaHeadlessBrowserII}%
As a reminder, this project is being built upon the following starter project on Repl.it, or cloned from GitHub.\newline%

%
\newpage%
\section{Advanced Node And Express}%
\label{sec:AdvancedNodeAndExpress}%
\subsection{Set up a Template Engine}%
\label{subsec:SetupaTemplateEngine}%
As a reminder, this project is built upon the following starter project on Repl.it, or clone from GitHub.\newline%
A template engine enables you to use static template files (such as those written in \_Pug\_) in your app. At runtime, the template engine replaces variables in a template file with actual values which can be supplied by your server. Then it transforms the template into a static HTML file that is sent to the client. This approach makes it easier to design an HTML page and allows for displaying variables on the page without needing to make an API call from the client.\newline%
Add `pug@\textasciitilde{}3.0.0` as a dependency in your `package.json` file.\newline%
Express needs to know which template engine you are using. We will use the `set` method to assign `pug` as the `view engine` property's value: `app.set('view engine', 'pug')`\newline%
Your page will not load until you correctly render the index file in the `views/pug` directory.\newline%
Change the argument of the `res.render()` declaration in the `/` route to be the file path to the `views/pug` directory. The path can be a relative path (relative to views), or an absolute path, and does not require a file extension.\newline%
If all went as planned, your app home page will stop showing the message "`Pug template is not defined.`" and will now display a message indicating you've successfully rendered the Pug template!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Use a Template Engine's Powers}%
\label{subsec:UseaTemplateEnginesPowers}%
One of the greatest features of using a template engine is being able to pass variables from the server to the template file before rendering it to HTML.\newline%
In your Pug file, you're able to use a variable by referencing the variable name as \#\{variable\_name\} inline with other text on an element or by using an equal sign on the element without a space such as p=variable\_name which assigns the variable's value to the p element's text.\newline%
We strongly recommend looking at the syntax and structure of Pug here on GitHub's README. Pug is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed to make a beautiful site.\newline%
Looking at our pug file 'index.pug' included in your project, we used the variables title and message.\newline%
To pass those along from our server, you will need to add an object as a second argument to your res.render with the variables and their values. For example, pass this object along setting the variables for your index view: \{title: 'Hello', message: 'Please login'\}\newline%
It should look like: res.render(process.cwd() + '/views/pug/index', \{title: 'Hello', message: 'Please login'\});\newline%
Now refresh your page and you should see those values rendered in your view in the correct spot as laid out in your index.pug file!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Set up Passport}%
\label{subsec:SetupPassport}%
It's time to set up Passport so we can finally start allowing a user to register or login to an account! In addition to Passport, we will use Express{-}session to handle sessions. Using this middleware saves the session id as a cookie in the client and allows us to access the session data using that id on the server. This way we keep personal account information out of the cookie used by the client to verify to our server they are authenticated and just keep the key to access the data stored on the server.\newline%
To set up Passport for use in your project, you will need to add it as a dependency first in your package.json. "passport": "\^{}0.3.2"\newline%
In addition, add Express{-}session as a dependency now as well. Express{-}session has a ton of advanced features you can use but for now we're just going to use the basics! "express{-}session": "\^{}1.15.0"\newline%
You will need to set up the session settings now and initialize Passport. Be sure to first create the variables 'session' and 'passport' to require 'express{-}session' and 'passport' respectively.\newline%
To set up your express app to use the session we'll define just a few basic options. Be sure to add 'SESSION\_SECRET' to your .env file and give it a random value. This is used to compute the hash used to encrypt your cookie!\newline%
```js\newline%
app.use(session(\{\newline%
  secret: process.env.SESSION\_SECRET,\newline%
  resave: true,\newline%
  saveUninitialized: true,\newline%
  cookie: \{ secure: false \}\newline%
\}));\newline%
```\newline%
As well you can go ahead and tell your express app to use 'passport.initialize()' and 'passport.session()'. (For example, app.use(passport.initialize());)\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Serialization of a User Object}%
\label{subsec:SerializationofaUserObject}%
Serialization and deserialization are important concepts in regards to authentication. To serialize an object means to convert its contents into a small key that can then be deserialized into the original object. This is what allows us to know who has communicated with the server without having to send the authentication data, like the username and password, at each request for a new page.\newline%
To set this up properly, we need to have a serialize function and a deserialize function. In Passport, we create these with passport.serializeUser( OURFUNCTION ) and passport.deserializeUser( OURFUNCTION )\newline%
The serializeUser is called with 2 arguments, the full user object and a callback used by passport. A unique key to identify that user should be returned in the callback, the easiest one to use being the user's \_id in the object. It should be unique as it generated by MongoDB. Similarly, deserializeUser is called with that key and a callback function for passport as well, but, this time, we have to take that key and return the full user object to the callback. To make a query search for a Mongo \_id, you will have to create const ObjectID = require('mongodb').ObjectID;, and then to use it you call new ObjectID(THE\_ID). Be sure to add MongoDB as a dependency. You can see this in the examples below:\newline%
```js\newline%
passport.serializeUser((user, done) => \{\newline%
  done(null, user.\_id);\newline%
\});\newline%
passport.deserializeUser((id, done) => \{\newline%
  myDataBase.findOne(\{ \_id: new ObjectID(id) \}, (err, doc) => \{\newline%
    done(null, null);\newline%
  \});\newline%
\});\newline%
```\newline%
NOTE: This deserializeUser will throw an error until we set up the DB in the next step, so for now comment out the whole block and just call done(null, null) in the function deserializeUser.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Implement the Serialization of a Passport User}%
\label{subsec:ImplementtheSerializationofaPassportUser}%
Right now, we're not loading an actual user object since we haven't set up our database. This can be done many different ways, but for our project we will connect to the database once when we start the server and keep a persistent connection for the full life{-}cycle of the app.\newline%
To do this, add your database's connection string (for example: mongodb+srv://:@cluster0{-}jvwxi.mongodb.net/?retryWrites=true\&w=majority) to the environment variable MONGO\_URI. This is used in the connection.js file.\newline%
\_You can set up a free database on MongoDB Atlas.\_\newline%
Now we want to connect to our database then start listening for requests. The purpose of this is to not allow requests before our database is connected or if there is a database error. To accomplish this, you will want to encompass your serialization and your app routes in the following code:\newline%
```js\newline%
myDB(async client => \{\newline%
  const myDataBase = await client.db('database').collection('users');\newline%
  // Be sure to change the title\newline%
  app.route('/').get((req, res) => \{\newline%
    //Change the response to render the Pug template\newline%
    res.render('pug', \{\newline%
      title: 'Connected to Database',\newline%
      message: 'Please login'\newline%
    \});\newline%
  \});\newline%
  // Serialization and deserialization here...\newline%
  // Be sure to add this...\newline%
\}).catch(e => \{\newline%
  app.route('/').get((req, res) => \{\newline%
    res.render('pug', \{ title: e, message: 'Unable to login' \});\newline%
  \});\newline%
\});\newline%
// app.listen out here...\newline%
```\newline%
Be sure to uncomment the myDataBase code in deserializeUser, and edit your done(null, null) to include the doc.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Authentication Strategies}%
\label{subsec:AuthenticationStrategies}%
A strategy is a way of authenticating a user. You can use a strategy for allowing users to authenticate based on locally saved information (if you have them register first) or from a variety of providers such as Google or GitHub. For this project, we will set up a local strategy. To see a list of the hundreds of strategies, visit Passport's site here.\newline%
Add passport{-}local as a dependency and add it to your server as follows: const LocalStrategy = require('passport{-}local');\newline%
Now you will have to tell passport to use an instantiated LocalStrategy object with a few settings defined. Make sure this (as well as everything from this point on) is encapsulated in the database connection since it relies on it!\newline%
```js\newline%
passport.use(new LocalStrategy(\newline%
  function(username, password, done) \{\newline%
    myDataBase.findOne(\{ username: username \}, function (err, user) \{\newline%
      console.log('User '+ username +' attempted to log in.');\newline%
      if (err) \{ return done(err); \}\newline%
      if (!user) \{ return done(null, false); \}\newline%
      if (password !== user.password) \{ return done(null, false); \}\newline%
      return done(null, user);\newline%
    \});\newline%
  \}\newline%
));\newline%
```\newline%
This is defining the process to use when we try to authenticate someone locally. First, it tries to find a user in our database with the username entered, then it checks for the password to match, then finally, if no errors have popped up that we checked for, like an incorrect password, the user's object is returned and they are authenticated.\newline%
Many strategies are set up using different settings, but generally it is easy to set it up based on the README in that strategy's repository. A good example of this is the GitHub strategy where we don't need to worry about a username or password because the user will be sent to GitHub's auth page to authenticate. As long as they are logged in and agree then GitHub returns their profile for us to use.\newline%
In the next step, we will set up how to actually call the authentication strategy to validate a user based on form data!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{How to Use Passport Strategies}%
\label{subsec:HowtoUsePassportStrategies}%
In the index.pug file supplied, there is actually a login form. It has previously been hidden because of the inline JavaScript if showLogin with the form indented after it. Before showLogin as a variable was never defined, so it never rendered the code block containing the form. Go ahead and on the res.render for that page add a new variable to the object showLogin: true. When you refresh your page, you should then see the form! This form is set up to POST on /login, so this is where we should set up to accept the POST and authenticate the user.\newline%
For this challenge you should add the route /login to accept a POST request. To authenticate on this route, you need to add a middleware to do so before then sending a response. This is done by just passing another argument with the middleware before your function(req,res) with your response! The middleware to use is passport.authenticate('local').\newline%
passport.authenticate can also take some options as an argument such as: \{ failureRedirect: '/' \} which is incredibly useful, so be sure to add that in as well. The response after using the middleware (which will only be called if the authentication middleware passes) should be to redirect the user to /profile and that route should render the view profile.pug.\newline%
If the authentication was successful, the user object will be saved in req.user.\newline%
At this point, if you enter a username and password in the form, it should redirect to the home page /, and the console of your server should display 'User \{USERNAME\} attempted to log in.', since we currently cannot login a user who isn't registered.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Create New Middleware}%
\label{subsec:CreateNewMiddleware}%
As is, any user can just go to /profile whether they have authenticated or not, by typing in the url. We want to prevent this, by checking if the user is authenticated first before rendering the profile page. This is the perfect example of when to create a middleware.\newline%
The challenge here is creating the middleware function ensureAuthenticated(req, res, next), which will check if a user is authenticated by calling passport's isAuthenticated method on the request which, in turn, checks if req.user is defined. If it is, then next() should be called, otherwise, we can just respond to the request with a redirect to our homepage to login. An implementation of this middleware is:\newline%
```js\newline%
function ensureAuthenticated(req, res, next) \{\newline%
  if (req.isAuthenticated()) \{\newline%
    return next();\newline%
  \}\newline%
  res.redirect('/');\newline%
\};\newline%
```\newline%
Now add ensureAuthenticated as a middleware to the request for the profile page before the argument to the get request containing the function that renders the page.\newline%
```js\newline%
app\newline%
 .route('/profile')\newline%
 .get(ensureAuthenticated, (req,res) => \{\newline%
    res.render(process.cwd() + '/views/pug/profile');\newline%
 \});\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{How to Put a Profile Together}%
\label{subsec:HowtoPutaProfileTogether}%
Now that we can ensure the user accessing the `/profile` is authenticated, we can use the information contained in `req.user` on our page!\newline%
Pass an object containing the property `username` and value of `req.user.username` as the second argument for the render method of the profile view. Then, go to your `profile.pug` view, and add the following line below the existing `h1` element, and at the same level of indentation:\newline%
```pug\newline%
h2.center\#welcome Welcome, \#\{username\}!\newline%
```\newline%
This creates an `h2` element with the class '`center`' and id '`welcome`' containing the text '`Welcome, `' followed by the username.\newline%
Also, in `profile.pug`, add a link referring to the `/logout` route, which will host the logic to unauthenticate a user.\newline%
```pug\newline%
a(href='/logout') Logout\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Logging a User Out}%
\label{subsec:LoggingaUserOut}%
Creating the logout logic is easy. The route should just unauthenticate the user and redirect to the home page instead of rendering any view.\newline%
In passport, unauthenticating a user is as easy as just calling req.logout(); before redirecting.\newline%
```js\newline%
app.route('/logout')\newline%
  .get((req, res) => \{\newline%
    req.logout();\newline%
    res.redirect('/');\newline%
\});\newline%
```\newline%
You may have noticed that we're not handling missing pages (404). The common way to handle this in Node is with the following middleware. Go ahead and add this in after all your other routes:\newline%
```js\newline%
app.use((req, res, next) => \{\newline%
  res.status(404)\newline%
    .type('text')\newline%
    .send('Not Found');\newline%
\});\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Registration of New Users}%
\label{subsec:RegistrationofNewUsers}%
Now we need to allow a new user on our site to register an account. On the res.render for the home page add a new variable to the object passed along{-}{-}showRegistration: true. When you refresh your page, you should then see the registration form that was already created in your index.pug file! This form is set up to POST on /register, so this is where we should set up to accept the POST and create the user object in the database.\newline%
The logic of the registration route should be as follows: Register the new user > Authenticate the new user > Redirect to /profile\newline%
The logic of step 1, registering the new user, should be as follows: Query database with a findOne command > if user is returned then it exists and redirect back to home OR if user is undefined and no error occurs then 'insertOne' into the database with the username and password, and, as long as no errors occur, call next to go to step 2, authenticating the new user, which we've already written the logic for in our POST /login route.\newline%
```js\newline%
app.route('/register')\newline%
  .post((req, res, next) => \{\newline%
    myDataBase.findOne(\{ username: req.body.username \}, function(err, user) \{\newline%
      if (err) \{\newline%
        next(err);\newline%
      \} else if (user) \{\newline%
        res.redirect('/');\newline%
      \} else \{\newline%
        myDataBase.insertOne(\{\newline%
          username: req.body.username,\newline%
          password: req.body.password\newline%
        \},\newline%
          (err, doc) => \{\newline%
            if (err) \{\newline%
              res.redirect('/');\newline%
            \} else \{\newline%
              // The inserted document is held within\newline%
              // the ops property of the doc\newline%
              next(null, doc.ops{[}0{]});\newline%
            \}\newline%
          \}\newline%
        )\newline%
      \}\newline%
    \})\newline%
  \},\newline%
    passport.authenticate('local', \{ failureRedirect: '/' \}),\newline%
    (req, res, next) => \{\newline%
      res.redirect('/profile');\newline%
    \}\newline%
  );\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%
**NOTE:** From this point onwards, issues can arise relating to the use of the \_picture{-}in{-}picture\_ browser. If you are using an online IDE which offers a preview of the app within the editor, it is recommended to open this preview in a new tab.\newline%

%
\subsection{Hashing Your Passwords}%
\label{subsec:HashingYourPasswords}%
Going back to the information security section, you may remember that storing plaintext passwords is never okay. Now it is time to implement BCrypt to solve this issue.\newline%
Add BCrypt as a dependency, and require it in your server. You will need to handle hashing in 2 key areas: where you handle registering/saving a new account, and when you check to see that a password is correct on login.\newline%
Currently on our registration route, you insert a user's password into the database like so: password: req.body.password. An easy way to implement saving a hash instead is to add the following before your database logic const hash = bcrypt.hashSync(req.body.password, 12);, and replacing the req.body.password in the database saving with just password: hash.\newline%
Finally, on our authentication strategy, we check for the following in our code before completing the process: if (password !== user.password) \{ return done(null, false); \}. After making the previous changes, now user.password is a hash. Before making a change to the existing code, notice how the statement is checking if the password is **not** equal then return non{-}authenticated. With this in mind, your code could look as follows to properly check the password entered against the hash:\newline%
```js\newline%
if (!bcrypt.compareSync(password, user.password)) \{ \newline%
  return done(null, false);\newline%
\}\newline%
```\newline%
That is all it takes to implement one of the most important security features when you have to store passwords!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Clean Up Your Project with Modules}%
\label{subsec:CleanUpYourProjectwithModules}%
Right now, everything you have is in your server.js file. This can lead to hard to manage code that isn't very expandable.\newline%
Create 2 new files: routes.js and auth.js\newline%
Both should start with the following code:\newline%
```js\newline%
module.exports = function (app, myDataBase) \{\newline%
\}\newline%
```\newline%
Now, in the top of your server file, require these files like so: const routes = require('./routes.js');\newline%
Right after you establish a successful connection with the database, instantiate each of them like so: routes(app, myDataBase)\newline%
Finally, take all of the routes in your server and paste them into your new files, and remove them from your server file. Also take the ensureAuthenticated function, since it was specifically created for routing. Now, you will have to correctly add the dependencies in which are used, such as const passport = require('passport');, at the very top, above the export line in your routes.js file.\newline%
Keep adding them until no more errors exist, and your server file no longer has any routing (**except for the route in the catch block**)!\newline%
Now do the same thing in your auth.js file with all of the things related to authentication such as the serialization and the setting up of the local strategy and erase them from your server file. Be sure to add the dependencies in and call auth(app, myDataBase) in the server in the same spot.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out an example of the completed project here.\newline%

%
\subsection{Implementation of Social Authentication}%
\label{subsec:ImplementationofSocialAuthentication}%
The basic path this kind of authentication will follow in your app is: User clicks a button or link sending them to our route to authenticate using a specific strategy (e.g. GitHub).Your route calls passport.authenticate('github') which redirects them to GitHub.The page the user lands on, on GitHub, allows them to login if they aren't already. It then asks them to approve access to their profile from our app.The user is then returned to our app at a specific callback url with their profile if they are approved.They are now authenticated, and your app should check if it is a returning profile, or save it in your database if it is not.\newline%
Strategies with OAuth require you to have at least a Client ID and a Client Secret which is a way for the service to verify who the authentication request is coming from and if it is valid. These are obtained from the site you are trying to implement authentication with, such as GitHub, and are unique to your app{-}{-}THEY ARE NOT TO BE SHARED and should never be uploaded to a public repository or written directly in your code. A common practice is to put them in your .env file and reference them like so: process.env.GITHUB\_CLIENT\_ID. For this challenge we're going to use the GitHub strategy.\newline%
Obtaining your Client ID and Secret from GitHub is done in your account profile settings under 'developer settings', then 'OAuth applications'. Click 'Register a new application', name your app, paste in the url to your Repl.it homepage (Not the project code's url), and lastly, for the callback url, paste in the same url as the homepage but with /auth/github/callback added on. This is where users will be redirected for us to handle after authenticating on GitHub. Save the returned information as 'GITHUB\_CLIENT\_ID' and 'GITHUB\_CLIENT\_SECRET' in your .env file.\newline%
In your routes.js file, add showSocialAuth: true to the homepage route, after showRegistration: true. Now, create 2 routes accepting GET requests: /auth/github and /auth/github/callback. The first should only call passport to authenticate 'github'. The second should call passport to authenticate 'github' with a failure redirect to /, and then if that is successful redirect to /profile (similar to our last project).\newline%
An example of how /auth/github/callback should look is similar to how we handled a normal login:\newline%
```js\newline%
app.route('/login')\newline%
  .post(passport.authenticate('local', \{ failureRedirect: '/' \}), (req,res) => \{\newline%
    res.redirect('/profile');\newline%
  \});\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project up to this point here.\newline%

%
\subsection{Implementation of Social Authentication II}%
\label{subsec:ImplementationofSocialAuthenticationII}%
The last part of setting up your GitHub authentication is to create the strategy itself. For this, you will need to add the dependency of 'passport{-}github' to your project and require it in your auth.js as GithubStrategy like this: const GitHubStrategy = require('passport{-}github').Strategy;. Do not forget to require and configure dotenv to use your environment variables.\newline%
To set up the GitHub strategy, you have to tell Passport to use an instantiated GitHubStrategy, which accepts 2 arguments: an object (containing clientID, clientSecret, and callbackURL) and a function to be called when a user is successfully authenticated, which will determine if the user is new and what fields to save initially in the user's database object. This is common across many strategies, but some may require more information as outlined in that specific strategy's GitHub README. For example, Google requires a scope as well which determines what kind of information your request is asking to be returned and asks the user to approve such access. The current strategy we are implementing has its usage outlined here, but we're going through it all right here on freeCodeCamp!\newline%
Here's how your new strategy should look at this point:\newline%
```js\newline%
passport.use(new GitHubStrategy(\{\newline%
  clientID: process.env.GITHUB\_CLIENT\_ID,\newline%
  clientSecret: process.env.GITHUB\_CLIENT\_SECRET,\newline%
  callbackURL: /*INSERT CALLBACK URL ENTERED INTO GITHUB HERE*/\newline%
\},\newline%
  function(accessToken, refreshToken, profile, cb) \{\newline%
    console.log(profile);\newline%
    //Database logic here with callback containing our user object\newline%
  \}\newline%
));\newline%
```\newline%
Your authentication won't be successful yet, and it will actually throw an error without the database logic and callback, but it should log your GitHub profile to your console if you try it!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Implementation of Social Authentication III}%
\label{subsec:ImplementationofSocialAuthenticationIII}%
The final part of the strategy is handling the profile returned from GitHub. We need to load the user's database object if it exists, or create one if it doesn't, and populate the fields from the profile, then return the user's object. GitHub supplies us a unique id within each profile which we can use to search with to serialize the user with (already implemented). Below is an example implementation you can use in your project{-}{-}it goes within the function that is the second argument for the new strategy, right below where console.log(profile); currently is:\newline%
```js\newline%
myDataBase.findOneAndUpdate(\newline%
  \{ id: profile.id \},\newline%
  \{\newline%
    \$setOnInsert: \{\newline%
      id: profile.id,\newline%
      name: profile.displayName || 'John Doe',\newline%
      photo: profile.photos{[}0{]}.value || '',\newline%
      email: Array.isArray(profile.emails)\newline%
        ? profile.emails{[}0{]}.value\newline%
        : 'No public email',\newline%
      created\_on: new Date(),\newline%
      provider: profile.provider || ''\newline%
    \},\newline%
    \$set: \{\newline%
      last\_login: new Date()\newline%
    \},\newline%
    \$inc: \{\newline%
      login\_count: 1\newline%
    \}\newline%
  \},\newline%
  \{ upsert: true, new: true \},\newline%
  (err, doc) => \{\newline%
    return cb(null, doc.value);\newline%
  \}\newline%
);\newline%
```\newline%
`findOneAndUpdate` allows you to search for an object and update it. If the object doesn't exist, it will be inserted and made available to the callback function. In this example, we always set `last\_login`, increment the `login\_count` by `1`, and only populate the majority of the fields when a new object (new user) is inserted. Notice the use of default values. Sometimes a profile returned won't have all the information filled out or the user will keep it private.  In this case, you handle it to prevent an error.\newline%
You should be able to login to your app now{-}{-}try it!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Set up the Environment}%
\label{subsec:SetuptheEnvironment}%
The following challenges will make use of the chat.pug file. So, in your routes.js file, add a GET route pointing to /chat which makes use of ensureAuthenticated, and renders chat.pug, with \{ user: req.user \} passed as an argument to the response. Now, alter your existing /auth/github/callback route to set the req.session.user\_id = req.user.id, and redirect to /chat.\newline%
Add http and socket.io as a dependency and require/instantiate them in your server defined as follows:\newline%
```javascript\newline%
const http = require('http').createServer(app);\newline%
const io = require('socket.io')(http);\newline%
```\newline%
Now that the \_http\_ server is mounted on the \_express app\_, you need to listen from the \_http\_ server. Change the line with app.listen to http.listen.\newline%
The first thing needing to be handled is listening for a new connection from the client. The on keyword does just that{-} listen for a specific event. It requires 2 arguments: a string containing the title of the event thats emitted, and a function with which the data is passed though. In the case of our connection listener, we use socket to define the data in the second argument. A socket is an individual client who is connected.\newline%
To listen for connections to your server, add the following within your database connection:\newline%
```javascript\newline%
io.on('connection', socket => \{\newline%
  console.log('A user has connected');\newline%
\});\newline%
```\newline%
Now for the client to connect, you just need to add the following to your client.js which is loaded by the page after you've authenticated:\newline%
```js\newline%
/*global io*/\newline%
let socket = io();\newline%
```\newline%
The comment suppresses the error you would normally see since 'io' is not defined in the file. We've already added a reliable CDN to the Socket.IO library on the page in chat.pug.\newline%
Now try loading up your app and authenticate and you should see in your server console 'A user has connected'!\newline%
Note:io() works only when connecting to a socket hosted on the same url/server. For connecting to an external socket hosted elsewhere, you would use io.connect('URL');.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Communicate by Emitting}%
\label{subsec:CommunicatebyEmitting}%
Emit is the most common way of communicating you will use. When you emit something from the server to 'io', you send an event's name and data to all the connected sockets. A good example of this concept would be emitting the current count of connected users each time a new user connects!\newline%
Start by adding a variable to keep track of the users, just before where you are currently listening for connections.\newline%
```js\newline%
let currentUsers = 0;\newline%
```\newline%
Now, when someone connects, you should increment the count before emitting the count. So, you will want to add the incrementer within the connection listener.\newline%
```js\newline%
++currentUsers;\newline%
```\newline%
Finally, after incrementing the count, you should emit the event (still within the connection listener). The event should be named 'user count', and the data should just be the currentUsers.\newline%
```js\newline%
io.emit('user count', currentUsers);\newline%
```\newline%
Now, you can implement a way for your client to listen for this event! Similar to listening for a connection on the server, you will use the on keyword.\newline%
```js\newline%
socket.on('user count', function(data) \{\newline%
  console.log(data);\newline%
\});\newline%
```\newline%
Now, try loading up your app, authenticate, and you should see in your client console '1' representing the current user count! Try loading more clients up, and authenticating to see the number go up.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Handle a Disconnect}%
\label{subsec:HandleaDisconnect}%
You may notice that up to now you have only been increasing the user count. Handling a user disconnecting is just as easy as handling the initial connect, except you have to listen for it on each socket instead of on the whole server.\newline%
To do this, add another listener inside the existing 'connect' listener that listens for 'disconnect' on the socket with no data passed through. You can test this functionality by just logging that a user has disconnected to the console.\newline%
```js\newline%
socket.on('disconnect', () => \{\newline%
  /*anything you want to do on disconnect*/\newline%
\});\newline%
```\newline%
To make sure clients continuously have the updated count of current users, you should decrease the currentUsers by 1 when the disconnect happens then emit the 'user count' event with the updated count!\newline%
Note: Just like 'disconnect', all other events that a socket can emit to the server should be handled within the connecting listener where we have 'socket' defined.\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Authentication with Socket.IO}%
\label{subsec:AuthenticationwithSocket.IO}%
Currently, you cannot determine who is connected to your web socket. While req.user contains the user object, that's only when your user interacts with the web server, and with web sockets you have no req (request) and therefore no user data. One way to solve the problem of knowing who is connected to your web socket is by parsing and decoding the cookie that contains the passport session then deserializing it to obtain the user object. Luckily, there is a package on NPM just for this that turns a once complex task into something simple!\newline%
Add passport.socketio, connect{-}mongo, and cookie{-}parser as dependencies and require them as passportSocketIo, MongoStore, and cookieParser respectively. Also, we need to initialize a new memory store, from express{-}session which we previously required. It should look like this:\newline%
```js\newline%
const MongoStore = require('connect{-}mongo')(session);\newline%
const URI = process.env.MONGO\_URI;\newline%
const store = new MongoStore(\{ url: URI \});\newline%
```\newline%
Now we just have to tell Socket.IO to use it and set the options. Be sure this is added before the existing socket code and not in the existing connection listener. For your server, it should look like this:\newline%
```js\newline%
io.use(\newline%
  passportSocketIo.authorize(\{\newline%
    cookieParser: cookieParser,\newline%
    key: 'express.sid',\newline%
    secret: process.env.SESSION\_SECRET,\newline%
    store: store,\newline%
    success: onAuthorizeSuccess,\newline%
    fail: onAuthorizeFail\newline%
  \})\newline%
);\newline%
```\newline%
Be sure to add the key and store to the session middleware mounted on the app. This is necessary to tell \_SocketIO\_ which session to relate to.\newline%
Now, define the success, and fail callback functions:\newline%
```js\newline%
function onAuthorizeSuccess(data, accept) \{\newline%
  console.log('successful connection to socket.io');\newline%
  accept(null, true);\newline%
\}\newline%
function onAuthorizeFail(data, message, error, accept) \{\newline%
  if (error) throw new Error(message);\newline%
  console.log('failed connection to socket.io:', message);\newline%
  accept(null, false);\newline%
\}\newline%
```\newline%
The user object is now accessible on your socket object as socket.request.user. For example, now you can add the following:\newline%
```js\newline%
console.log('user ' + socket.request.user.name + ' connected');\newline%
```\newline%
It will log to the server console who has connected!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project up to this point here.\newline%

%
\subsection{Announce New Users}%
\label{subsec:AnnounceNewUsers}%
Many chat rooms are able to announce when a user connects or disconnects and then display that to all of the connected users in the chat. Seeing as though you already are emitting an event on connect and disconnect, you will just have to modify this event to support such a feature. The most logical way of doing so is sending 3 pieces of data with the event: the name of the user who connected/disconnected, the current user count, and if that name connected or disconnected.\newline%
Change the event name to 'user', and pass an object along containing the fields 'name', 'currentUsers', and 'connected' (to be true in case of connection, or false for disconnection of the user sent). Be sure to change both 'user count' events and set the disconnect one to send false for the field 'connected' instead of true like the event emitted on connect.\newline%
```js\newline%
io.emit('user', \{\newline%
  name: socket.request.user.name,\newline%
  currentUsers,\newline%
  connected: true\newline%
\});\newline%
```\newline%
Now your client will have all the necessary information to correctly display the current user count and announce when a user connects or disconnects! To handle this event on the client side we should listen for 'user', then update the current user count by using jQuery to change the text of \#num{-}users to '\{NUMBER\} users online', as well as append a <li> to the unordered list with id messages with '\{NAME\} has \{joined/left\} the chat.'.\newline%
An implementation of this could look like the following:\newline%
```js\newline%
socket.on('user', data => \{\newline%
  \$('\#num{-}users').text(data.currentUsers + ' users online');\newline%
  let message =\newline%
    data.name +\newline%
    (data.connected ? ' has joined the chat.' : ' has left the chat.');\newline%
  \$('\#messages').append(\$('').html('' + message + ''));\newline%
\});\newline%
```\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\subsection{Send and Display Chat Messages}%
\label{subsec:SendandDisplayChatMessages}%
It's time you start allowing clients to send a chat message to the server to emit to all the clients! In your client.js file, you should see there is already a block of code handling when the message form is submitted.\newline%
```js\newline%
\$('form').submit(function() \{\newline%
  /*logic*/\newline%
\});\newline%
```\newline%
Within the form submit code, you should emit an event after you define messageToSend but before you clear the text box \#m. The event should be named 'chat message' and the data should just be messageToSend.\newline%
```js\newline%
socket.emit('chat message', messageToSend);\newline%
```\newline%
Now, on your server, you should be listening to the socket for the event 'chat message' with the data being named message. Once the event is received, it should emit the event 'chat message' to all sockets io.emit with the data being an object containing name and message.\newline%
In client.js, you should now listen for event 'chat message' and, when received, append a list item to \#messages with the name, a colon, and the message!\newline%
At this point, the chat should be fully functional and sending messages across all clients!\newline%
Submit your page when you think you've got it right. If you're running into errors, you can check out the project completed up to this point here.\newline%

%
\newpage%
\section{Quality Assurance Projects}%
\label{sec:QualityAssuranceProjects}%
\subsection{Metric{-}Imperial Converter}%
\label{subsec:Metric{-}ImperialConverter}%
Build a full stack JavaScript app that is functionally similar to this: https://metric{-}imperial{-}converter.freecodecamp.rocks/.\newline%
Working on this project will involve you writing your code on Repl.it on our starter project. After completing this project you can copy your public Repl.it URL (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\newline%
Start this project on Repl.it using this link or clone this repository on GitHub! If you use Repl.it, remember to save the link to your project somewhere safe!\newline%

%
\subsection{Issue Tracker}%
\label{subsec:IssueTracker}%
Build a full stack JavaScript app that is functionally similar to this: https://issue{-}tracker.freecodecamp.rocks/.\newline%
Working on this project will involve you writing your code on Repl.it on our starter project. After completing this project you can copy your public Repl.it URL (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\newline%
Start this project on Repl.it using this link or clone this repository on GitHub! If you use Repl.it, remember to save the link to your project somewhere safe!\newline%

%
\subsection{Personal Library}%
\label{subsec:PersonalLibrary}%
Build a full stack JavaScript app that is functionally similar to this: https://personal{-}library.freecodecamp.rocks/.\newline%
Working on this project will involve you writing your code on Repl.it on our starter project. After completing this project you can copy your public Repl.it URL (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but must be publicly visible for our testing.\newline%
Start this project on Repl.it using this link or clone this repository on GitHub! If you use Repl.it, remember to save the link to your project somewhere safe!\newline%

%
\subsection{Sudoku Solver}%
\label{subsec:SudokuSolver}%
Build a full stack JavaScript app that is functionally similar to this: https://sudoku{-}solver.freecodecamp.rocks/.\newline%
Working on this project will involve you writing your code on Repl.it on our starter project. After completing this project you can copy your public Repl.it URL (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\newline%
Start this project on Repl.it using this link or clone this repository on GitHub! If you use Repl.it, remember to save the link to your project somewhere safe!\newline%

%
\subsection{American British Translator}%
\label{subsec:AmericanBritishTranslator}%
Build a full stack JavaScript app that is functionally similar to this: https://american{-}british{-}translator.freecodecamp.rocks/.\newline%
Working on this project will involve you writing your code on Repl.it on our starter project. After completing this project you can copy your public Repl.it URL (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\newline%
Start this project on Repl.it using this link or clone this repository on GitHub! If you use Repl.it, remember to save the link to your project somewhere safe!\newline%

%
\newpage%
\end{document}